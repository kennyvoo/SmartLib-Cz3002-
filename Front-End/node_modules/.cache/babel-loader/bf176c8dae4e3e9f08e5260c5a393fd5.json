{"ast":null,"code":"import { PureComponent, createElement } from 'react';\nimport { array, arrayOf, func, number, object, oneOf, oneOfType, string } from 'prop-types';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\n\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nfunction __rest(s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];\n  return t;\n}\n\nvar ALIGNMENT;\n\n(function (ALIGNMENT) {\n  ALIGNMENT[\"AUTO\"] = \"auto\";\n  ALIGNMENT[\"START\"] = \"start\";\n  ALIGNMENT[\"CENTER\"] = \"center\";\n  ALIGNMENT[\"END\"] = \"end\";\n})(ALIGNMENT || (ALIGNMENT = {}));\n\nvar DIRECTION;\n\n(function (DIRECTION) {\n  DIRECTION[\"HORIZONTAL\"] = \"horizontal\";\n  DIRECTION[\"VERTICAL\"] = \"vertical\";\n})(DIRECTION || (DIRECTION = {}));\n\nvar SCROLL_CHANGE_REASON;\n\n(function (SCROLL_CHANGE_REASON) {\n  SCROLL_CHANGE_REASON[\"OBSERVED\"] = \"observed\";\n  SCROLL_CHANGE_REASON[\"REQUESTED\"] = \"requested\";\n})(SCROLL_CHANGE_REASON || (SCROLL_CHANGE_REASON = {}));\n\nvar scrollProp = (_a = {}, _a[DIRECTION.VERTICAL] = 'scrollTop', _a[DIRECTION.HORIZONTAL] = 'scrollLeft', _a);\nvar sizeProp = (_b = {}, _b[DIRECTION.VERTICAL] = 'height', _b[DIRECTION.HORIZONTAL] = 'width', _b);\nvar positionProp = (_c = {}, _c[DIRECTION.VERTICAL] = 'top', _c[DIRECTION.HORIZONTAL] = 'left', _c);\nvar marginProp = (_d = {}, _d[DIRECTION.VERTICAL] = 'marginTop', _d[DIRECTION.HORIZONTAL] = 'marginLeft', _d);\nvar oppositeMarginProp = (_e = {}, _e[DIRECTION.VERTICAL] = 'marginBottom', _e[DIRECTION.HORIZONTAL] = 'marginRight', _e);\n\nvar _a;\n\nvar _b;\n\nvar _c;\n\nvar _d;\n\nvar _e;\n/* Forked from react-virtualized ðŸ’– */\n\n\nvar SizeAndPositionManager =\n/** @class */\nfunction () {\n  function SizeAndPositionManager(_a) {\n    var itemCount = _a.itemCount,\n        itemSizeGetter = _a.itemSizeGetter,\n        estimatedItemSize = _a.estimatedItemSize;\n    this.itemSizeGetter = itemSizeGetter;\n    this.itemCount = itemCount;\n    this.estimatedItemSize = estimatedItemSize; // Cache of size and position data for items, mapped by item index.\n\n    this.itemSizeAndPositionData = {}; // Measurements for items up to this index can be trusted; items afterward should be estimated.\n\n    this.lastMeasuredIndex = -1;\n  }\n\n  SizeAndPositionManager.prototype.updateConfig = function (_a) {\n    var itemCount = _a.itemCount,\n        itemSizeGetter = _a.itemSizeGetter,\n        estimatedItemSize = _a.estimatedItemSize;\n\n    if (itemCount != null) {\n      this.itemCount = itemCount;\n    }\n\n    if (estimatedItemSize != null) {\n      this.estimatedItemSize = estimatedItemSize;\n    }\n\n    if (itemSizeGetter != null) {\n      this.itemSizeGetter = itemSizeGetter;\n    }\n  };\n\n  SizeAndPositionManager.prototype.getLastMeasuredIndex = function () {\n    return this.lastMeasuredIndex;\n  };\n  /**\n   * This method returns the size and position for the item at the specified index.\n   * It just-in-time calculates (or used cached values) for items leading up to the index.\n   */\n\n\n  SizeAndPositionManager.prototype.getSizeAndPositionForIndex = function (index) {\n    if (index < 0 || index >= this.itemCount) {\n      throw Error(\"Requested index \" + index + \" is outside of range 0..\" + this.itemCount);\n    }\n\n    if (index > this.lastMeasuredIndex) {\n      var lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n      var offset = lastMeasuredSizeAndPosition.offset + lastMeasuredSizeAndPosition.size;\n\n      for (var i = this.lastMeasuredIndex + 1; i <= index; i++) {\n        var size = this.itemSizeGetter(i);\n\n        if (size == null || isNaN(size)) {\n          throw Error(\"Invalid size returned for index \" + i + \" of value \" + size);\n        }\n\n        this.itemSizeAndPositionData[i] = {\n          offset: offset,\n          size: size\n        };\n        offset += size;\n      }\n\n      this.lastMeasuredIndex = index;\n    }\n\n    return this.itemSizeAndPositionData[index];\n  };\n\n  SizeAndPositionManager.prototype.getSizeAndPositionOfLastMeasuredItem = function () {\n    return this.lastMeasuredIndex >= 0 ? this.itemSizeAndPositionData[this.lastMeasuredIndex] : {\n      offset: 0,\n      size: 0\n    };\n  };\n  /**\n   * Total size of all items being measured.\n   * This value will be completedly estimated initially.\n   * As items as measured the estimate will be updated.\n   */\n\n\n  SizeAndPositionManager.prototype.getTotalSize = function () {\n    var lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n    return lastMeasuredSizeAndPosition.offset + lastMeasuredSizeAndPosition.size + (this.itemCount - this.lastMeasuredIndex - 1) * this.estimatedItemSize;\n  };\n  /**\n   * Determines a new offset that ensures a certain item is visible, given the alignment.\n   *\n   * @param align Desired alignment within container; one of \"start\" (default), \"center\", or \"end\"\n   * @param containerSize Size (width or height) of the container viewport\n   * @return Offset to use to ensure the specified item is visible\n   */\n\n\n  SizeAndPositionManager.prototype.getUpdatedOffsetForIndex = function (_a) {\n    var _b = _a.align,\n        align = _b === void 0 ? ALIGNMENT.START : _b,\n        containerSize = _a.containerSize,\n        currentOffset = _a.currentOffset,\n        targetIndex = _a.targetIndex;\n\n    if (containerSize <= 0) {\n      return 0;\n    }\n\n    var datum = this.getSizeAndPositionForIndex(targetIndex);\n    var maxOffset = datum.offset;\n    var minOffset = maxOffset - containerSize + datum.size;\n    var idealOffset;\n\n    switch (align) {\n      case ALIGNMENT.END:\n        idealOffset = minOffset;\n        break;\n\n      case ALIGNMENT.CENTER:\n        idealOffset = maxOffset - (containerSize - datum.size) / 2;\n        break;\n\n      case ALIGNMENT.START:\n        idealOffset = maxOffset;\n        break;\n\n      default:\n        idealOffset = Math.max(minOffset, Math.min(maxOffset, currentOffset));\n    }\n\n    var totalSize = this.getTotalSize();\n    return Math.max(0, Math.min(totalSize - containerSize, idealOffset));\n  };\n\n  SizeAndPositionManager.prototype.getVisibleRange = function (_a) {\n    var containerSize = _a.containerSize,\n        offset = _a.offset,\n        overscanCount = _a.overscanCount;\n    var totalSize = this.getTotalSize();\n\n    if (totalSize === 0) {\n      return {};\n    }\n\n    var maxOffset = offset + containerSize;\n    var start = this.findNearestItem(offset);\n\n    if (typeof start === 'undefined') {\n      throw Error(\"Invalid offset \" + offset + \" specified\");\n    }\n\n    var datum = this.getSizeAndPositionForIndex(start);\n    offset = datum.offset + datum.size;\n    var stop = start;\n\n    while (offset < maxOffset && stop < this.itemCount - 1) {\n      stop++;\n      offset += this.getSizeAndPositionForIndex(stop).size;\n    }\n\n    if (overscanCount) {\n      start = Math.max(0, start - overscanCount);\n      stop = Math.min(stop + overscanCount, this.itemCount - 1);\n    }\n\n    return {\n      start: start,\n      stop: stop\n    };\n  };\n  /**\n   * Clear all cached values for items after the specified index.\n   * This method should be called for any item that has changed its size.\n   * It will not immediately perform any calculations; they'll be performed the next time getSizeAndPositionForIndex() is called.\n   */\n\n\n  SizeAndPositionManager.prototype.resetItem = function (index) {\n    this.lastMeasuredIndex = Math.min(this.lastMeasuredIndex, index - 1);\n  };\n  /**\n   * Searches for the item (index) nearest the specified offset.\n   *\n   * If no exact match is found the next lowest item index will be returned.\n   * This allows partially visible items (with offsets just before/above the fold) to be visible.\n   */\n\n\n  SizeAndPositionManager.prototype.findNearestItem = function (offset) {\n    if (isNaN(offset)) {\n      throw Error(\"Invalid offset \" + offset + \" specified\");\n    } // Our search algorithms find the nearest match at or below the specified offset.\n    // So make sure the offset is at least 0 or no match will be found.\n\n\n    offset = Math.max(0, offset);\n    var lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n    var lastMeasuredIndex = Math.max(0, this.lastMeasuredIndex);\n\n    if (lastMeasuredSizeAndPosition.offset >= offset) {\n      // If we've already measured items within this range just use a binary search as it's faster.\n      return this.binarySearch({\n        high: lastMeasuredIndex,\n        low: 0,\n        offset: offset\n      });\n    } else {\n      // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n      // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n      // The overall complexity for this approach is O(log n).\n      return this.exponentialSearch({\n        index: lastMeasuredIndex,\n        offset: offset\n      });\n    }\n  };\n\n  SizeAndPositionManager.prototype.binarySearch = function (_a) {\n    var low = _a.low,\n        high = _a.high,\n        offset = _a.offset;\n    var middle = 0;\n    var currentOffset = 0;\n\n    while (low <= high) {\n      middle = low + Math.floor((high - low) / 2);\n      currentOffset = this.getSizeAndPositionForIndex(middle).offset;\n\n      if (currentOffset === offset) {\n        return middle;\n      } else if (currentOffset < offset) {\n        low = middle + 1;\n      } else if (currentOffset > offset) {\n        high = middle - 1;\n      }\n    }\n\n    if (low > 0) {\n      return low - 1;\n    }\n\n    return 0;\n  };\n\n  SizeAndPositionManager.prototype.exponentialSearch = function (_a) {\n    var index = _a.index,\n        offset = _a.offset;\n    var interval = 1;\n\n    while (index < this.itemCount && this.getSizeAndPositionForIndex(index).offset < offset) {\n      index += interval;\n      interval *= 2;\n    }\n\n    return this.binarySearch({\n      high: Math.min(index, this.itemCount - 1),\n      low: Math.floor(index / 2),\n      offset: offset\n    });\n  };\n\n  return SizeAndPositionManager;\n}();\n\nvar STYLE_WRAPPER = {\n  overflow: 'auto',\n  willChange: 'transform',\n  WebkitOverflowScrolling: 'touch'\n};\nvar STYLE_INNER = {\n  position: 'relative',\n  width: '100%',\n  minHeight: '100%'\n};\nvar STYLE_ITEM = {\n  position: 'absolute',\n  top: 0,\n  left: 0,\n  width: '100%'\n};\n\nvar STYLE_STICKY_ITEM = __assign({}, STYLE_ITEM, {\n  position: 'sticky'\n});\n\nvar VirtualList =\n/** @class */\nfunction (_super) {\n  __extends(VirtualList, _super);\n\n  function VirtualList() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.itemSizeGetter = function (itemSize) {\n      return function (index) {\n        return _this.getSize(index, itemSize);\n      };\n    };\n\n    _this.sizeAndPositionManager = new SizeAndPositionManager({\n      itemCount: _this.props.itemCount,\n      itemSizeGetter: _this.itemSizeGetter(_this.props.itemSize),\n      estimatedItemSize: _this.getEstimatedItemSize()\n    });\n    _this.state = {\n      offset: _this.props.scrollOffset || _this.props.scrollToIndex != null && _this.getOffsetForIndex(_this.props.scrollToIndex) || 0,\n      scrollChangeReason: SCROLL_CHANGE_REASON.REQUESTED\n    };\n    _this.styleCache = {};\n\n    _this.getRef = function (node) {\n      _this.rootNode = node;\n    };\n\n    _this.handleScroll = function (event) {\n      var onScroll = _this.props.onScroll;\n\n      var offset = _this.getNodeOffset();\n\n      if (offset < 0 || _this.state.offset === offset || event.target !== _this.rootNode) {\n        return;\n      }\n\n      _this.setState({\n        offset: offset,\n        scrollChangeReason: SCROLL_CHANGE_REASON.OBSERVED\n      });\n\n      if (typeof onScroll === 'function') {\n        onScroll(offset, event);\n      }\n    };\n\n    return _this;\n  }\n\n  VirtualList.prototype.componentDidMount = function () {\n    var _a = this.props,\n        scrollOffset = _a.scrollOffset,\n        scrollToIndex = _a.scrollToIndex;\n    this.rootNode.addEventListener('scroll', this.handleScroll, {\n      passive: true\n    });\n\n    if (scrollOffset != null) {\n      this.scrollTo(scrollOffset);\n    } else if (scrollToIndex != null) {\n      this.scrollTo(this.getOffsetForIndex(scrollToIndex));\n    }\n  };\n\n  VirtualList.prototype.componentWillReceiveProps = function (nextProps) {\n    var _a = this.props,\n        estimatedItemSize = _a.estimatedItemSize,\n        itemCount = _a.itemCount,\n        itemSize = _a.itemSize,\n        scrollOffset = _a.scrollOffset,\n        scrollToAlignment = _a.scrollToAlignment,\n        scrollToIndex = _a.scrollToIndex;\n    var scrollPropsHaveChanged = nextProps.scrollToIndex !== scrollToIndex || nextProps.scrollToAlignment !== scrollToAlignment;\n    var itemPropsHaveChanged = nextProps.itemCount !== itemCount || nextProps.itemSize !== itemSize || nextProps.estimatedItemSize !== estimatedItemSize;\n\n    if (nextProps.itemSize !== itemSize) {\n      this.sizeAndPositionManager.updateConfig({\n        itemSizeGetter: this.itemSizeGetter(nextProps.itemSize)\n      });\n    }\n\n    if (nextProps.itemCount !== itemCount || nextProps.estimatedItemSize !== estimatedItemSize) {\n      this.sizeAndPositionManager.updateConfig({\n        itemCount: nextProps.itemCount,\n        estimatedItemSize: this.getEstimatedItemSize(nextProps)\n      });\n    }\n\n    if (itemPropsHaveChanged) {\n      this.recomputeSizes();\n    }\n\n    if (nextProps.scrollOffset !== scrollOffset) {\n      this.setState({\n        offset: nextProps.scrollOffset || 0,\n        scrollChangeReason: SCROLL_CHANGE_REASON.REQUESTED\n      });\n    } else if (typeof nextProps.scrollToIndex === 'number' && (scrollPropsHaveChanged || itemPropsHaveChanged)) {\n      this.setState({\n        offset: this.getOffsetForIndex(nextProps.scrollToIndex, nextProps.scrollToAlignment, nextProps.itemCount),\n        scrollChangeReason: SCROLL_CHANGE_REASON.REQUESTED\n      });\n    }\n  };\n\n  VirtualList.prototype.componentDidUpdate = function (_, prevState) {\n    var _a = this.state,\n        offset = _a.offset,\n        scrollChangeReason = _a.scrollChangeReason;\n\n    if (prevState.offset !== offset && scrollChangeReason === SCROLL_CHANGE_REASON.REQUESTED) {\n      this.scrollTo(offset);\n    }\n  };\n\n  VirtualList.prototype.componentWillUnmount = function () {\n    this.rootNode.removeEventListener('scroll', this.handleScroll);\n  };\n\n  VirtualList.prototype.scrollTo = function (value) {\n    var _a = this.props.scrollDirection,\n        scrollDirection = _a === void 0 ? DIRECTION.VERTICAL : _a;\n    this.rootNode[scrollProp[scrollDirection]] = value;\n  };\n\n  VirtualList.prototype.getOffsetForIndex = function (index, scrollToAlignment, itemCount) {\n    if (scrollToAlignment === void 0) {\n      scrollToAlignment = this.props.scrollToAlignment;\n    }\n\n    if (itemCount === void 0) {\n      itemCount = this.props.itemCount;\n    }\n\n    var _a = this.props.scrollDirection,\n        scrollDirection = _a === void 0 ? DIRECTION.VERTICAL : _a;\n\n    if (index < 0 || index >= itemCount) {\n      index = 0;\n    }\n\n    return this.sizeAndPositionManager.getUpdatedOffsetForIndex({\n      align: scrollToAlignment,\n      containerSize: this.props[sizeProp[scrollDirection]],\n      currentOffset: this.state && this.state.offset || 0,\n      targetIndex: index\n    });\n  };\n\n  VirtualList.prototype.recomputeSizes = function (startIndex) {\n    if (startIndex === void 0) {\n      startIndex = 0;\n    }\n\n    this.styleCache = {};\n    this.sizeAndPositionManager.resetItem(startIndex);\n  };\n\n  VirtualList.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.props,\n        estimatedItemSize = _a.estimatedItemSize,\n        height = _a.height,\n        _b = _a.overscanCount,\n        overscanCount = _b === void 0 ? 3 : _b,\n        renderItem = _a.renderItem,\n        itemCount = _a.itemCount,\n        itemSize = _a.itemSize,\n        onItemsRendered = _a.onItemsRendered,\n        onScroll = _a.onScroll,\n        _c = _a.scrollDirection,\n        scrollDirection = _c === void 0 ? DIRECTION.VERTICAL : _c,\n        scrollOffset = _a.scrollOffset,\n        scrollToIndex = _a.scrollToIndex,\n        scrollToAlignment = _a.scrollToAlignment,\n        stickyIndices = _a.stickyIndices,\n        style = _a.style,\n        width = _a.width,\n        props = __rest(_a, [\"estimatedItemSize\", \"height\", \"overscanCount\", \"renderItem\", \"itemCount\", \"itemSize\", \"onItemsRendered\", \"onScroll\", \"scrollDirection\", \"scrollOffset\", \"scrollToIndex\", \"scrollToAlignment\", \"stickyIndices\", \"style\", \"width\"]);\n\n    var offset = this.state.offset;\n\n    var _d = this.sizeAndPositionManager.getVisibleRange({\n      containerSize: this.props[sizeProp[scrollDirection]] || 0,\n      offset: offset,\n      overscanCount: overscanCount\n    }),\n        start = _d.start,\n        stop = _d.stop;\n\n    var items = [];\n\n    var wrapperStyle = __assign({}, STYLE_WRAPPER, style, {\n      height: height,\n      width: width\n    });\n\n    var innerStyle = __assign({}, STYLE_INNER, (_e = {}, _e[sizeProp[scrollDirection]] = this.sizeAndPositionManager.getTotalSize(), _e));\n\n    if (stickyIndices != null && stickyIndices.length !== 0) {\n      stickyIndices.forEach(function (index) {\n        return items.push(renderItem({\n          index: index,\n          style: _this.getStyle(index, true)\n        }));\n      });\n\n      if (scrollDirection === DIRECTION.HORIZONTAL) {\n        innerStyle.display = 'flex';\n      }\n    }\n\n    if (typeof start !== 'undefined' && typeof stop !== 'undefined') {\n      for (var index = start; index <= stop; index++) {\n        if (stickyIndices != null && stickyIndices.includes(index)) {\n          continue;\n        }\n\n        items.push(renderItem({\n          index: index,\n          style: this.getStyle(index, false)\n        }));\n      }\n\n      if (typeof onItemsRendered === 'function') {\n        onItemsRendered({\n          startIndex: start,\n          stopIndex: stop\n        });\n      }\n    }\n\n    return createElement(\"div\", __assign({\n      ref: this.getRef\n    }, props, {\n      style: wrapperStyle\n    }), createElement(\"div\", {\n      style: innerStyle\n    }, items));\n\n    var _e;\n  };\n\n  VirtualList.prototype.getNodeOffset = function () {\n    var _a = this.props.scrollDirection,\n        scrollDirection = _a === void 0 ? DIRECTION.VERTICAL : _a;\n    return this.rootNode[scrollProp[scrollDirection]];\n  };\n\n  VirtualList.prototype.getEstimatedItemSize = function (props) {\n    if (props === void 0) {\n      props = this.props;\n    }\n\n    return props.estimatedItemSize || typeof props.itemSize === 'number' && props.itemSize || 50;\n  };\n\n  VirtualList.prototype.getSize = function (index, itemSize) {\n    if (typeof itemSize === 'function') {\n      return itemSize(index);\n    }\n\n    return Array.isArray(itemSize) ? itemSize[index] : itemSize;\n  };\n\n  VirtualList.prototype.getStyle = function (index, sticky) {\n    var style = this.styleCache[index];\n\n    if (style) {\n      return style;\n    }\n\n    var _a = this.props.scrollDirection,\n        scrollDirection = _a === void 0 ? DIRECTION.VERTICAL : _a;\n\n    var _b = this.sizeAndPositionManager.getSizeAndPositionForIndex(index),\n        size = _b.size,\n        offset = _b.offset;\n\n    return this.styleCache[index] = sticky ? __assign({}, STYLE_STICKY_ITEM, (_c = {}, _c[sizeProp[scrollDirection]] = size, _c[marginProp[scrollDirection]] = offset, _c[oppositeMarginProp[scrollDirection]] = -(offset + size), _c.zIndex = 1, _c)) : __assign({}, STYLE_ITEM, (_d = {}, _d[sizeProp[scrollDirection]] = size, _d[positionProp[scrollDirection]] = offset, _d));\n\n    var _c, _d;\n  };\n\n  VirtualList.defaultProps = {\n    overscanCount: 3,\n    scrollDirection: DIRECTION.VERTICAL,\n    width: '100%'\n  };\n  VirtualList.propTypes = {\n    estimatedItemSize: number,\n    height: oneOfType([number, string]).isRequired,\n    itemCount: number.isRequired,\n    itemSize: oneOfType([number, array, func]).isRequired,\n    onScroll: func,\n    onItemsRendered: func,\n    overscanCount: number,\n    renderItem: func.isRequired,\n    scrollOffset: number,\n    scrollToIndex: number,\n    scrollToAlignment: oneOf([ALIGNMENT.AUTO, ALIGNMENT.START, ALIGNMENT.CENTER, ALIGNMENT.END]),\n    scrollDirection: oneOf([DIRECTION.HORIZONTAL, DIRECTION.VERTICAL]),\n    stickyIndices: arrayOf(number),\n    style: object,\n    width: oneOfType([number, string])\n  };\n  return VirtualList;\n}(PureComponent);\n\nexport { DIRECTION as ScrollDirection };\nexport default VirtualList;","map":{"version":3,"sources":["D:/Projects/CZ3002-Lab-SmartLib/CZ3002_Xeon/Front-End/node_modules/react-tiny-virtual-list/build/react-tiny-virtual-list.es.js"],"names":["PureComponent","createElement","array","arrayOf","func","number","object","oneOf","oneOfType","string","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","constructor","prototype","create","__assign","assign","t","s","i","n","arguments","length","call","apply","__rest","e","indexOf","getOwnPropertySymbols","ALIGNMENT","DIRECTION","SCROLL_CHANGE_REASON","scrollProp","_a","VERTICAL","HORIZONTAL","sizeProp","_b","positionProp","_c","marginProp","_d","oppositeMarginProp","_e","SizeAndPositionManager","itemCount","itemSizeGetter","estimatedItemSize","itemSizeAndPositionData","lastMeasuredIndex","updateConfig","getLastMeasuredIndex","getSizeAndPositionForIndex","index","Error","lastMeasuredSizeAndPosition","getSizeAndPositionOfLastMeasuredItem","offset","size","isNaN","getTotalSize","getUpdatedOffsetForIndex","align","START","containerSize","currentOffset","targetIndex","datum","maxOffset","minOffset","idealOffset","END","CENTER","Math","max","min","totalSize","getVisibleRange","overscanCount","start","findNearestItem","stop","resetItem","binarySearch","high","low","exponentialSearch","middle","floor","interval","STYLE_WRAPPER","overflow","willChange","WebkitOverflowScrolling","STYLE_INNER","position","width","minHeight","STYLE_ITEM","top","left","STYLE_STICKY_ITEM","VirtualList","_super","_this","itemSize","getSize","sizeAndPositionManager","props","getEstimatedItemSize","state","scrollOffset","scrollToIndex","getOffsetForIndex","scrollChangeReason","REQUESTED","styleCache","getRef","node","rootNode","handleScroll","event","onScroll","getNodeOffset","target","setState","OBSERVED","componentDidMount","addEventListener","passive","scrollTo","componentWillReceiveProps","nextProps","scrollToAlignment","scrollPropsHaveChanged","itemPropsHaveChanged","recomputeSizes","componentDidUpdate","_","prevState","componentWillUnmount","removeEventListener","value","scrollDirection","startIndex","render","height","renderItem","onItemsRendered","stickyIndices","style","items","wrapperStyle","innerStyle","forEach","push","getStyle","display","includes","stopIndex","ref","isArray","sticky","zIndex","defaultProps","propTypes","isRequired","AUTO","ScrollDirection"],"mappings":"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","sourcesContent":["import { PureComponent, createElement } from 'react';\nimport { array, arrayOf, func, number, object, oneOf, oneOfType, string } from 'prop-types';\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\n\nvar ALIGNMENT;\n(function (ALIGNMENT) {\n    ALIGNMENT[\"AUTO\"] = \"auto\";\n    ALIGNMENT[\"START\"] = \"start\";\n    ALIGNMENT[\"CENTER\"] = \"center\";\n    ALIGNMENT[\"END\"] = \"end\";\n})(ALIGNMENT || (ALIGNMENT = {}));\nvar DIRECTION;\n(function (DIRECTION) {\n    DIRECTION[\"HORIZONTAL\"] = \"horizontal\";\n    DIRECTION[\"VERTICAL\"] = \"vertical\";\n})(DIRECTION || (DIRECTION = {}));\nvar SCROLL_CHANGE_REASON;\n(function (SCROLL_CHANGE_REASON) {\n    SCROLL_CHANGE_REASON[\"OBSERVED\"] = \"observed\";\n    SCROLL_CHANGE_REASON[\"REQUESTED\"] = \"requested\";\n})(SCROLL_CHANGE_REASON || (SCROLL_CHANGE_REASON = {}));\nvar scrollProp = (_a = {}, _a[DIRECTION.VERTICAL] = 'scrollTop', _a[DIRECTION.HORIZONTAL] = 'scrollLeft', _a);\nvar sizeProp = (_b = {}, _b[DIRECTION.VERTICAL] = 'height', _b[DIRECTION.HORIZONTAL] = 'width', _b);\nvar positionProp = (_c = {}, _c[DIRECTION.VERTICAL] = 'top', _c[DIRECTION.HORIZONTAL] = 'left', _c);\nvar marginProp = (_d = {}, _d[DIRECTION.VERTICAL] = 'marginTop', _d[DIRECTION.HORIZONTAL] = 'marginLeft', _d);\nvar oppositeMarginProp = (_e = {}, _e[DIRECTION.VERTICAL] = 'marginBottom', _e[DIRECTION.HORIZONTAL] = 'marginRight', _e);\nvar _a;\nvar _b;\nvar _c;\nvar _d;\nvar _e;\n\n/* Forked from react-virtualized ðŸ’– */\nvar SizeAndPositionManager = /** @class */function () {\n    function SizeAndPositionManager(_a) {\n        var itemCount = _a.itemCount,\n            itemSizeGetter = _a.itemSizeGetter,\n            estimatedItemSize = _a.estimatedItemSize;\n        this.itemSizeGetter = itemSizeGetter;\n        this.itemCount = itemCount;\n        this.estimatedItemSize = estimatedItemSize;\n        // Cache of size and position data for items, mapped by item index.\n        this.itemSizeAndPositionData = {};\n        // Measurements for items up to this index can be trusted; items afterward should be estimated.\n        this.lastMeasuredIndex = -1;\n    }\n    SizeAndPositionManager.prototype.updateConfig = function (_a) {\n        var itemCount = _a.itemCount,\n            itemSizeGetter = _a.itemSizeGetter,\n            estimatedItemSize = _a.estimatedItemSize;\n        if (itemCount != null) {\n            this.itemCount = itemCount;\n        }\n        if (estimatedItemSize != null) {\n            this.estimatedItemSize = estimatedItemSize;\n        }\n        if (itemSizeGetter != null) {\n            this.itemSizeGetter = itemSizeGetter;\n        }\n    };\n    SizeAndPositionManager.prototype.getLastMeasuredIndex = function () {\n        return this.lastMeasuredIndex;\n    };\n    /**\n     * This method returns the size and position for the item at the specified index.\n     * It just-in-time calculates (or used cached values) for items leading up to the index.\n     */\n    SizeAndPositionManager.prototype.getSizeAndPositionForIndex = function (index) {\n        if (index < 0 || index >= this.itemCount) {\n            throw Error(\"Requested index \" + index + \" is outside of range 0..\" + this.itemCount);\n        }\n        if (index > this.lastMeasuredIndex) {\n            var lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n            var offset = lastMeasuredSizeAndPosition.offset + lastMeasuredSizeAndPosition.size;\n            for (var i = this.lastMeasuredIndex + 1; i <= index; i++) {\n                var size = this.itemSizeGetter(i);\n                if (size == null || isNaN(size)) {\n                    throw Error(\"Invalid size returned for index \" + i + \" of value \" + size);\n                }\n                this.itemSizeAndPositionData[i] = {\n                    offset: offset,\n                    size: size\n                };\n                offset += size;\n            }\n            this.lastMeasuredIndex = index;\n        }\n        return this.itemSizeAndPositionData[index];\n    };\n    SizeAndPositionManager.prototype.getSizeAndPositionOfLastMeasuredItem = function () {\n        return this.lastMeasuredIndex >= 0 ? this.itemSizeAndPositionData[this.lastMeasuredIndex] : { offset: 0, size: 0 };\n    };\n    /**\n     * Total size of all items being measured.\n     * This value will be completedly estimated initially.\n     * As items as measured the estimate will be updated.\n     */\n    SizeAndPositionManager.prototype.getTotalSize = function () {\n        var lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n        return lastMeasuredSizeAndPosition.offset + lastMeasuredSizeAndPosition.size + (this.itemCount - this.lastMeasuredIndex - 1) * this.estimatedItemSize;\n    };\n    /**\n     * Determines a new offset that ensures a certain item is visible, given the alignment.\n     *\n     * @param align Desired alignment within container; one of \"start\" (default), \"center\", or \"end\"\n     * @param containerSize Size (width or height) of the container viewport\n     * @return Offset to use to ensure the specified item is visible\n     */\n    SizeAndPositionManager.prototype.getUpdatedOffsetForIndex = function (_a) {\n        var _b = _a.align,\n            align = _b === void 0 ? ALIGNMENT.START : _b,\n            containerSize = _a.containerSize,\n            currentOffset = _a.currentOffset,\n            targetIndex = _a.targetIndex;\n        if (containerSize <= 0) {\n            return 0;\n        }\n        var datum = this.getSizeAndPositionForIndex(targetIndex);\n        var maxOffset = datum.offset;\n        var minOffset = maxOffset - containerSize + datum.size;\n        var idealOffset;\n        switch (align) {\n            case ALIGNMENT.END:\n                idealOffset = minOffset;\n                break;\n            case ALIGNMENT.CENTER:\n                idealOffset = maxOffset - (containerSize - datum.size) / 2;\n                break;\n            case ALIGNMENT.START:\n                idealOffset = maxOffset;\n                break;\n            default:\n                idealOffset = Math.max(minOffset, Math.min(maxOffset, currentOffset));\n        }\n        var totalSize = this.getTotalSize();\n        return Math.max(0, Math.min(totalSize - containerSize, idealOffset));\n    };\n    SizeAndPositionManager.prototype.getVisibleRange = function (_a) {\n        var containerSize = _a.containerSize,\n            offset = _a.offset,\n            overscanCount = _a.overscanCount;\n        var totalSize = this.getTotalSize();\n        if (totalSize === 0) {\n            return {};\n        }\n        var maxOffset = offset + containerSize;\n        var start = this.findNearestItem(offset);\n        if (typeof start === 'undefined') {\n            throw Error(\"Invalid offset \" + offset + \" specified\");\n        }\n        var datum = this.getSizeAndPositionForIndex(start);\n        offset = datum.offset + datum.size;\n        var stop = start;\n        while (offset < maxOffset && stop < this.itemCount - 1) {\n            stop++;\n            offset += this.getSizeAndPositionForIndex(stop).size;\n        }\n        if (overscanCount) {\n            start = Math.max(0, start - overscanCount);\n            stop = Math.min(stop + overscanCount, this.itemCount - 1);\n        }\n        return {\n            start: start,\n            stop: stop\n        };\n    };\n    /**\n     * Clear all cached values for items after the specified index.\n     * This method should be called for any item that has changed its size.\n     * It will not immediately perform any calculations; they'll be performed the next time getSizeAndPositionForIndex() is called.\n     */\n    SizeAndPositionManager.prototype.resetItem = function (index) {\n        this.lastMeasuredIndex = Math.min(this.lastMeasuredIndex, index - 1);\n    };\n    /**\n     * Searches for the item (index) nearest the specified offset.\n     *\n     * If no exact match is found the next lowest item index will be returned.\n     * This allows partially visible items (with offsets just before/above the fold) to be visible.\n     */\n    SizeAndPositionManager.prototype.findNearestItem = function (offset) {\n        if (isNaN(offset)) {\n            throw Error(\"Invalid offset \" + offset + \" specified\");\n        }\n        // Our search algorithms find the nearest match at or below the specified offset.\n        // So make sure the offset is at least 0 or no match will be found.\n        offset = Math.max(0, offset);\n        var lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n        var lastMeasuredIndex = Math.max(0, this.lastMeasuredIndex);\n        if (lastMeasuredSizeAndPosition.offset >= offset) {\n            // If we've already measured items within this range just use a binary search as it's faster.\n            return this.binarySearch({\n                high: lastMeasuredIndex,\n                low: 0,\n                offset: offset\n            });\n        } else {\n            // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n            // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n            // The overall complexity for this approach is O(log n).\n            return this.exponentialSearch({\n                index: lastMeasuredIndex,\n                offset: offset\n            });\n        }\n    };\n    SizeAndPositionManager.prototype.binarySearch = function (_a) {\n        var low = _a.low,\n            high = _a.high,\n            offset = _a.offset;\n        var middle = 0;\n        var currentOffset = 0;\n        while (low <= high) {\n            middle = low + Math.floor((high - low) / 2);\n            currentOffset = this.getSizeAndPositionForIndex(middle).offset;\n            if (currentOffset === offset) {\n                return middle;\n            } else if (currentOffset < offset) {\n                low = middle + 1;\n            } else if (currentOffset > offset) {\n                high = middle - 1;\n            }\n        }\n        if (low > 0) {\n            return low - 1;\n        }\n        return 0;\n    };\n    SizeAndPositionManager.prototype.exponentialSearch = function (_a) {\n        var index = _a.index,\n            offset = _a.offset;\n        var interval = 1;\n        while (index < this.itemCount && this.getSizeAndPositionForIndex(index).offset < offset) {\n            index += interval;\n            interval *= 2;\n        }\n        return this.binarySearch({\n            high: Math.min(index, this.itemCount - 1),\n            low: Math.floor(index / 2),\n            offset: offset\n        });\n    };\n    return SizeAndPositionManager;\n}();\n\nvar STYLE_WRAPPER = {\n    overflow: 'auto',\n    willChange: 'transform',\n    WebkitOverflowScrolling: 'touch'\n};\nvar STYLE_INNER = {\n    position: 'relative',\n    width: '100%',\n    minHeight: '100%'\n};\nvar STYLE_ITEM = {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    width: '100%'\n};\nvar STYLE_STICKY_ITEM = __assign({}, STYLE_ITEM, { position: 'sticky' });\nvar VirtualList = /** @class */function (_super) {\n    __extends(VirtualList, _super);\n    function VirtualList() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.itemSizeGetter = function (itemSize) {\n            return function (index) {\n                return _this.getSize(index, itemSize);\n            };\n        };\n        _this.sizeAndPositionManager = new SizeAndPositionManager({\n            itemCount: _this.props.itemCount,\n            itemSizeGetter: _this.itemSizeGetter(_this.props.itemSize),\n            estimatedItemSize: _this.getEstimatedItemSize()\n        });\n        _this.state = {\n            offset: _this.props.scrollOffset || _this.props.scrollToIndex != null && _this.getOffsetForIndex(_this.props.scrollToIndex) || 0,\n            scrollChangeReason: SCROLL_CHANGE_REASON.REQUESTED\n        };\n        _this.styleCache = {};\n        _this.getRef = function (node) {\n            _this.rootNode = node;\n        };\n        _this.handleScroll = function (event) {\n            var onScroll = _this.props.onScroll;\n            var offset = _this.getNodeOffset();\n            if (offset < 0 || _this.state.offset === offset || event.target !== _this.rootNode) {\n                return;\n            }\n            _this.setState({\n                offset: offset,\n                scrollChangeReason: SCROLL_CHANGE_REASON.OBSERVED\n            });\n            if (typeof onScroll === 'function') {\n                onScroll(offset, event);\n            }\n        };\n        return _this;\n    }\n    VirtualList.prototype.componentDidMount = function () {\n        var _a = this.props,\n            scrollOffset = _a.scrollOffset,\n            scrollToIndex = _a.scrollToIndex;\n        this.rootNode.addEventListener('scroll', this.handleScroll, {\n            passive: true\n        });\n        if (scrollOffset != null) {\n            this.scrollTo(scrollOffset);\n        } else if (scrollToIndex != null) {\n            this.scrollTo(this.getOffsetForIndex(scrollToIndex));\n        }\n    };\n    VirtualList.prototype.componentWillReceiveProps = function (nextProps) {\n        var _a = this.props,\n            estimatedItemSize = _a.estimatedItemSize,\n            itemCount = _a.itemCount,\n            itemSize = _a.itemSize,\n            scrollOffset = _a.scrollOffset,\n            scrollToAlignment = _a.scrollToAlignment,\n            scrollToIndex = _a.scrollToIndex;\n        var scrollPropsHaveChanged = nextProps.scrollToIndex !== scrollToIndex || nextProps.scrollToAlignment !== scrollToAlignment;\n        var itemPropsHaveChanged = nextProps.itemCount !== itemCount || nextProps.itemSize !== itemSize || nextProps.estimatedItemSize !== estimatedItemSize;\n        if (nextProps.itemSize !== itemSize) {\n            this.sizeAndPositionManager.updateConfig({\n                itemSizeGetter: this.itemSizeGetter(nextProps.itemSize)\n            });\n        }\n        if (nextProps.itemCount !== itemCount || nextProps.estimatedItemSize !== estimatedItemSize) {\n            this.sizeAndPositionManager.updateConfig({\n                itemCount: nextProps.itemCount,\n                estimatedItemSize: this.getEstimatedItemSize(nextProps)\n            });\n        }\n        if (itemPropsHaveChanged) {\n            this.recomputeSizes();\n        }\n        if (nextProps.scrollOffset !== scrollOffset) {\n            this.setState({\n                offset: nextProps.scrollOffset || 0,\n                scrollChangeReason: SCROLL_CHANGE_REASON.REQUESTED\n            });\n        } else if (typeof nextProps.scrollToIndex === 'number' && (scrollPropsHaveChanged || itemPropsHaveChanged)) {\n            this.setState({\n                offset: this.getOffsetForIndex(nextProps.scrollToIndex, nextProps.scrollToAlignment, nextProps.itemCount),\n                scrollChangeReason: SCROLL_CHANGE_REASON.REQUESTED\n            });\n        }\n    };\n    VirtualList.prototype.componentDidUpdate = function (_, prevState) {\n        var _a = this.state,\n            offset = _a.offset,\n            scrollChangeReason = _a.scrollChangeReason;\n        if (prevState.offset !== offset && scrollChangeReason === SCROLL_CHANGE_REASON.REQUESTED) {\n            this.scrollTo(offset);\n        }\n    };\n    VirtualList.prototype.componentWillUnmount = function () {\n        this.rootNode.removeEventListener('scroll', this.handleScroll);\n    };\n    VirtualList.prototype.scrollTo = function (value) {\n        var _a = this.props.scrollDirection,\n            scrollDirection = _a === void 0 ? DIRECTION.VERTICAL : _a;\n        this.rootNode[scrollProp[scrollDirection]] = value;\n    };\n    VirtualList.prototype.getOffsetForIndex = function (index, scrollToAlignment, itemCount) {\n        if (scrollToAlignment === void 0) {\n            scrollToAlignment = this.props.scrollToAlignment;\n        }\n        if (itemCount === void 0) {\n            itemCount = this.props.itemCount;\n        }\n        var _a = this.props.scrollDirection,\n            scrollDirection = _a === void 0 ? DIRECTION.VERTICAL : _a;\n        if (index < 0 || index >= itemCount) {\n            index = 0;\n        }\n        return this.sizeAndPositionManager.getUpdatedOffsetForIndex({\n            align: scrollToAlignment,\n            containerSize: this.props[sizeProp[scrollDirection]],\n            currentOffset: this.state && this.state.offset || 0,\n            targetIndex: index\n        });\n    };\n    VirtualList.prototype.recomputeSizes = function (startIndex) {\n        if (startIndex === void 0) {\n            startIndex = 0;\n        }\n        this.styleCache = {};\n        this.sizeAndPositionManager.resetItem(startIndex);\n    };\n    VirtualList.prototype.render = function () {\n        var _this = this;\n        var _a = this.props,\n            estimatedItemSize = _a.estimatedItemSize,\n            height = _a.height,\n            _b = _a.overscanCount,\n            overscanCount = _b === void 0 ? 3 : _b,\n            renderItem = _a.renderItem,\n            itemCount = _a.itemCount,\n            itemSize = _a.itemSize,\n            onItemsRendered = _a.onItemsRendered,\n            onScroll = _a.onScroll,\n            _c = _a.scrollDirection,\n            scrollDirection = _c === void 0 ? DIRECTION.VERTICAL : _c,\n            scrollOffset = _a.scrollOffset,\n            scrollToIndex = _a.scrollToIndex,\n            scrollToAlignment = _a.scrollToAlignment,\n            stickyIndices = _a.stickyIndices,\n            style = _a.style,\n            width = _a.width,\n            props = __rest(_a, [\"estimatedItemSize\", \"height\", \"overscanCount\", \"renderItem\", \"itemCount\", \"itemSize\", \"onItemsRendered\", \"onScroll\", \"scrollDirection\", \"scrollOffset\", \"scrollToIndex\", \"scrollToAlignment\", \"stickyIndices\", \"style\", \"width\"]);\n        var offset = this.state.offset;\n        var _d = this.sizeAndPositionManager.getVisibleRange({\n            containerSize: this.props[sizeProp[scrollDirection]] || 0,\n            offset: offset,\n            overscanCount: overscanCount\n        }),\n            start = _d.start,\n            stop = _d.stop;\n        var items = [];\n        var wrapperStyle = __assign({}, STYLE_WRAPPER, style, { height: height, width: width });\n        var innerStyle = __assign({}, STYLE_INNER, (_e = {}, _e[sizeProp[scrollDirection]] = this.sizeAndPositionManager.getTotalSize(), _e));\n        if (stickyIndices != null && stickyIndices.length !== 0) {\n            stickyIndices.forEach(function (index) {\n                return items.push(renderItem({\n                    index: index,\n                    style: _this.getStyle(index, true)\n                }));\n            });\n            if (scrollDirection === DIRECTION.HORIZONTAL) {\n                innerStyle.display = 'flex';\n            }\n        }\n        if (typeof start !== 'undefined' && typeof stop !== 'undefined') {\n            for (var index = start; index <= stop; index++) {\n                if (stickyIndices != null && stickyIndices.includes(index)) {\n                    continue;\n                }\n                items.push(renderItem({\n                    index: index,\n                    style: this.getStyle(index, false)\n                }));\n            }\n            if (typeof onItemsRendered === 'function') {\n                onItemsRendered({\n                    startIndex: start,\n                    stopIndex: stop\n                });\n            }\n        }\n        return createElement(\"div\", __assign({ ref: this.getRef }, props, { style: wrapperStyle }), createElement(\"div\", { style: innerStyle }, items));\n        var _e;\n    };\n    VirtualList.prototype.getNodeOffset = function () {\n        var _a = this.props.scrollDirection,\n            scrollDirection = _a === void 0 ? DIRECTION.VERTICAL : _a;\n        return this.rootNode[scrollProp[scrollDirection]];\n    };\n    VirtualList.prototype.getEstimatedItemSize = function (props) {\n        if (props === void 0) {\n            props = this.props;\n        }\n        return props.estimatedItemSize || typeof props.itemSize === 'number' && props.itemSize || 50;\n    };\n    VirtualList.prototype.getSize = function (index, itemSize) {\n        if (typeof itemSize === 'function') {\n            return itemSize(index);\n        }\n        return Array.isArray(itemSize) ? itemSize[index] : itemSize;\n    };\n    VirtualList.prototype.getStyle = function (index, sticky) {\n        var style = this.styleCache[index];\n        if (style) {\n            return style;\n        }\n        var _a = this.props.scrollDirection,\n            scrollDirection = _a === void 0 ? DIRECTION.VERTICAL : _a;\n        var _b = this.sizeAndPositionManager.getSizeAndPositionForIndex(index),\n            size = _b.size,\n            offset = _b.offset;\n        return this.styleCache[index] = sticky ? __assign({}, STYLE_STICKY_ITEM, (_c = {}, _c[sizeProp[scrollDirection]] = size, _c[marginProp[scrollDirection]] = offset, _c[oppositeMarginProp[scrollDirection]] = -(offset + size), _c.zIndex = 1, _c)) : __assign({}, STYLE_ITEM, (_d = {}, _d[sizeProp[scrollDirection]] = size, _d[positionProp[scrollDirection]] = offset, _d));\n        var _c, _d;\n    };\n    VirtualList.defaultProps = {\n        overscanCount: 3,\n        scrollDirection: DIRECTION.VERTICAL,\n        width: '100%'\n    };\n    VirtualList.propTypes = {\n        estimatedItemSize: number,\n        height: oneOfType([number, string]).isRequired,\n        itemCount: number.isRequired,\n        itemSize: oneOfType([number, array, func]).isRequired,\n        onScroll: func,\n        onItemsRendered: func,\n        overscanCount: number,\n        renderItem: func.isRequired,\n        scrollOffset: number,\n        scrollToIndex: number,\n        scrollToAlignment: oneOf([ALIGNMENT.AUTO, ALIGNMENT.START, ALIGNMENT.CENTER, ALIGNMENT.END]),\n        scrollDirection: oneOf([DIRECTION.HORIZONTAL, DIRECTION.VERTICAL]),\n        stickyIndices: arrayOf(number),\n        style: object,\n        width: oneOfType([number, string])\n    };\n    return VirtualList;\n}(PureComponent);\n\nexport { DIRECTION as ScrollDirection };\nexport default VirtualList;\n"]},"metadata":{},"sourceType":"module"}