{"ast":null,"code":"(function () {\n  var computeScore, countDir, file_coeff, getExtension, getExtensionScore, isMatch, scorePath, scoreSize, tau_depth, _ref;\n\n  _ref = require('./scorer'), isMatch = _ref.isMatch, computeScore = _ref.computeScore, scoreSize = _ref.scoreSize;\n  tau_depth = 20;\n  file_coeff = 2.5;\n\n  exports.score = function (string, query, options) {\n    var allowErrors, preparedQuery, score, string_lw;\n    preparedQuery = options.preparedQuery, allowErrors = options.allowErrors;\n\n    if (!(allowErrors || isMatch(string, preparedQuery.core_lw, preparedQuery.core_up))) {\n      return 0;\n    }\n\n    string_lw = string.toLowerCase();\n    score = computeScore(string, string_lw, preparedQuery);\n    score = scorePath(string, string_lw, score, options);\n    return Math.ceil(score);\n  };\n\n  scorePath = function (subject, subject_lw, fullPathScore, options) {\n    var alpha, basePathScore, basePos, depth, end, extAdjust, fileLength, pathSeparator, preparedQuery, useExtensionBonus;\n\n    if (fullPathScore === 0) {\n      return 0;\n    }\n\n    preparedQuery = options.preparedQuery, useExtensionBonus = options.useExtensionBonus, pathSeparator = options.pathSeparator;\n    end = subject.length - 1;\n\n    while (subject[end] === pathSeparator) {\n      end--;\n    }\n\n    basePos = subject.lastIndexOf(pathSeparator, end);\n    fileLength = end - basePos;\n    extAdjust = 1.0;\n\n    if (useExtensionBonus) {\n      extAdjust += getExtensionScore(subject_lw, preparedQuery.ext, basePos, end, 2);\n      fullPathScore *= extAdjust;\n    }\n\n    if (basePos === -1) {\n      return fullPathScore;\n    }\n\n    depth = preparedQuery.depth;\n\n    while (basePos > -1 && depth-- > 0) {\n      basePos = subject.lastIndexOf(pathSeparator, basePos - 1);\n    }\n\n    basePathScore = basePos === -1 ? fullPathScore : extAdjust * computeScore(subject.slice(basePos + 1, end + 1), subject_lw.slice(basePos + 1, end + 1), preparedQuery);\n    alpha = 0.5 * tau_depth / (tau_depth + countDir(subject, end + 1, pathSeparator));\n    return alpha * basePathScore + (1 - alpha) * fullPathScore * scoreSize(0, file_coeff * fileLength);\n  };\n\n  exports.countDir = countDir = function (path, end, pathSeparator) {\n    var count, i;\n\n    if (end < 1) {\n      return 0;\n    }\n\n    count = 0;\n    i = -1;\n\n    while (++i < end && path[i] === pathSeparator) {\n      continue;\n    }\n\n    while (++i < end) {\n      if (path[i] === pathSeparator) {\n        count++;\n\n        while (++i < end && path[i] === pathSeparator) {\n          continue;\n        }\n      }\n    }\n\n    return count;\n  };\n\n  exports.getExtension = getExtension = function (str) {\n    var pos;\n    pos = str.lastIndexOf(\".\");\n\n    if (pos < 0) {\n      return \"\";\n    } else {\n      return str.substr(pos + 1);\n    }\n  };\n\n  getExtensionScore = function (candidate, ext, startPos, endPos, maxDepth) {\n    var m, matched, n, pos;\n\n    if (!ext.length) {\n      return 0;\n    }\n\n    pos = candidate.lastIndexOf(\".\", endPos);\n\n    if (!(pos > startPos)) {\n      return 0;\n    }\n\n    n = ext.length;\n    m = endPos - pos;\n\n    if (m < n) {\n      n = m;\n      m = ext.length;\n    }\n\n    pos++;\n    matched = -1;\n\n    while (++matched < n) {\n      if (candidate[pos + matched] !== ext[matched]) {\n        break;\n      }\n    }\n\n    if (matched === 0 && maxDepth > 0) {\n      return 0.9 * getExtensionScore(candidate, ext, startPos, pos - 2, maxDepth - 1);\n    }\n\n    return matched / m;\n  };\n}).call(this);","map":{"version":3,"sources":["D:/Projects/CZ3002-Lab-SmartLib/CZ3002_Xeon/Front-End/node_modules/fuzzaldrin-plus/lib/pathScorer.js"],"names":["computeScore","countDir","file_coeff","getExtension","getExtensionScore","isMatch","scorePath","scoreSize","tau_depth","_ref","require","exports","score","string","query","options","allowErrors","preparedQuery","string_lw","core_lw","core_up","toLowerCase","Math","ceil","subject","subject_lw","fullPathScore","alpha","basePathScore","basePos","depth","end","extAdjust","fileLength","pathSeparator","useExtensionBonus","length","lastIndexOf","ext","slice","path","count","i","str","pos","substr","candidate","startPos","endPos","maxDepth","m","matched","n","call"],"mappings":"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","sourcesContent":["(function() {\n  var computeScore, countDir, file_coeff, getExtension, getExtensionScore, isMatch, scorePath, scoreSize, tau_depth, _ref;\n\n  _ref = require('./scorer'), isMatch = _ref.isMatch, computeScore = _ref.computeScore, scoreSize = _ref.scoreSize;\n\n  tau_depth = 20;\n\n  file_coeff = 2.5;\n\n  exports.score = function(string, query, options) {\n    var allowErrors, preparedQuery, score, string_lw;\n    preparedQuery = options.preparedQuery, allowErrors = options.allowErrors;\n    if (!(allowErrors || isMatch(string, preparedQuery.core_lw, preparedQuery.core_up))) {\n      return 0;\n    }\n    string_lw = string.toLowerCase();\n    score = computeScore(string, string_lw, preparedQuery);\n    score = scorePath(string, string_lw, score, options);\n    return Math.ceil(score);\n  };\n\n  scorePath = function(subject, subject_lw, fullPathScore, options) {\n    var alpha, basePathScore, basePos, depth, end, extAdjust, fileLength, pathSeparator, preparedQuery, useExtensionBonus;\n    if (fullPathScore === 0) {\n      return 0;\n    }\n    preparedQuery = options.preparedQuery, useExtensionBonus = options.useExtensionBonus, pathSeparator = options.pathSeparator;\n    end = subject.length - 1;\n    while (subject[end] === pathSeparator) {\n      end--;\n    }\n    basePos = subject.lastIndexOf(pathSeparator, end);\n    fileLength = end - basePos;\n    extAdjust = 1.0;\n    if (useExtensionBonus) {\n      extAdjust += getExtensionScore(subject_lw, preparedQuery.ext, basePos, end, 2);\n      fullPathScore *= extAdjust;\n    }\n    if (basePos === -1) {\n      return fullPathScore;\n    }\n    depth = preparedQuery.depth;\n    while (basePos > -1 && depth-- > 0) {\n      basePos = subject.lastIndexOf(pathSeparator, basePos - 1);\n    }\n    basePathScore = basePos === -1 ? fullPathScore : extAdjust * computeScore(subject.slice(basePos + 1, end + 1), subject_lw.slice(basePos + 1, end + 1), preparedQuery);\n    alpha = 0.5 * tau_depth / (tau_depth + countDir(subject, end + 1, pathSeparator));\n    return alpha * basePathScore + (1 - alpha) * fullPathScore * scoreSize(0, file_coeff * fileLength);\n  };\n\n  exports.countDir = countDir = function(path, end, pathSeparator) {\n    var count, i;\n    if (end < 1) {\n      return 0;\n    }\n    count = 0;\n    i = -1;\n    while (++i < end && path[i] === pathSeparator) {\n      continue;\n    }\n    while (++i < end) {\n      if (path[i] === pathSeparator) {\n        count++;\n        while (++i < end && path[i] === pathSeparator) {\n          continue;\n        }\n      }\n    }\n    return count;\n  };\n\n  exports.getExtension = getExtension = function(str) {\n    var pos;\n    pos = str.lastIndexOf(\".\");\n    if (pos < 0) {\n      return \"\";\n    } else {\n      return str.substr(pos + 1);\n    }\n  };\n\n  getExtensionScore = function(candidate, ext, startPos, endPos, maxDepth) {\n    var m, matched, n, pos;\n    if (!ext.length) {\n      return 0;\n    }\n    pos = candidate.lastIndexOf(\".\", endPos);\n    if (!(pos > startPos)) {\n      return 0;\n    }\n    n = ext.length;\n    m = endPos - pos;\n    if (m < n) {\n      n = m;\n      m = ext.length;\n    }\n    pos++;\n    matched = -1;\n    while (++matched < n) {\n      if (candidate[pos + matched] !== ext[matched]) {\n        break;\n      }\n    }\n    if (matched === 0 && maxDepth > 0) {\n      return 0.9 * getExtensionScore(candidate, ext, startPos, pos - 2, maxDepth - 1);\n    }\n    return matched / m;\n  };\n\n}).call(this);\n"]},"metadata":{},"sourceType":"script"}