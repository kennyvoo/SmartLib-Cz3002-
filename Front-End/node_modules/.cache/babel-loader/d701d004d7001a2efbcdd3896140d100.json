{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport React, { memo, useState, useEffect, useRef } from 'react';\nimport PropTypes from 'prop-types';\nimport { Transition } from 'react-transition-group';\nimport { Portal } from '../../portal';\nimport { Stack } from '../../stack';\nimport { StackingOrder, Position } from '../../constants';\nimport { useMergedRef, usePrevious } from '../../hooks';\nimport getPosition from './getPosition';\nvar animationEasing = {\n  spring: \"cubic-bezier(0.175, 0.885, 0.320, 1.175)\"\n};\n\nvar getCSS = function getCSS(_ref) {\n  var initialScale = _ref.initialScale,\n      animationDuration = _ref.animationDuration;\n  return {\n    position: 'fixed',\n    opacity: 0,\n    transitionTimingFunction: animationEasing.spring,\n    transitionDuration: \"\".concat(animationDuration, \"ms\"),\n    transitionProperty: 'opacity, transform',\n    transform: \"scale(\".concat(initialScale, \") translateY(-1px)\"),\n    '&[data-state=\"entering\"], &[data-state=\"entered\"]': {\n      opacity: 1,\n      visibility: 'visible',\n      transform: \"scale(1)\"\n    },\n    '&[data-state=\"exiting\"]': {\n      opacity: 0,\n      transform: 'scale(1)'\n    }\n  };\n};\n\nvar noop = function noop() {};\n\nvar initialDimensions = {\n  left: 0,\n  top: 0,\n  height: 0,\n  width: 0,\n  transformOrigin: null\n};\nvar Positioner = memo(function Positioner(props) {\n  var target = props.target,\n      isShown = props.isShown,\n      children = props.children,\n      _props$initialScale = props.initialScale,\n      initialScale = _props$initialScale === void 0 ? 0.9 : _props$initialScale,\n      _props$animationDurat = props.animationDuration,\n      animationDuration = _props$animationDurat === void 0 ? 300 : _props$animationDurat,\n      _props$position = props.position,\n      position = _props$position === void 0 ? Position.BOTTOM : _props$position,\n      _props$bodyOffset = props.bodyOffset,\n      bodyOffset = _props$bodyOffset === void 0 ? 6 : _props$bodyOffset,\n      _props$targetOffset = props.targetOffset,\n      targetOffset = _props$targetOffset === void 0 ? 6 : _props$targetOffset,\n      _props$onOpenComplete = props.onOpenComplete,\n      onOpenComplete = _props$onOpenComplete === void 0 ? noop : _props$onOpenComplete,\n      _props$onCloseComplet = props.onCloseComplete,\n      onCloseComplete = _props$onCloseComplet === void 0 ? noop : _props$onCloseComplet;\n\n  var _useState = useState(initialDimensions),\n      _useState2 = _slicedToArray(_useState, 2),\n      dimensions = _useState2[0],\n      setDimensions = _useState2[1];\n\n  var previousDimensions = usePrevious(dimensions, initialDimensions);\n  var latestAnimationFrame = useRef();\n  var transitionState = useRef();\n  var positionerRef = useRef();\n  var targetRef = useRef();\n  var setTargetRef = useMergedRef(targetRef);\n  var getRef = useMergedRef(positionerRef); // Call `update` whenever the component has \"entered\" and dimensions change\n\n  useEffect(function () {\n    if (transitionState.current === 'entered') {\n      latestAnimationFrame.current = requestAnimationFrame(function () {\n        update(previousDimensions.height, previousDimensions.width);\n      });\n    }\n\n    return function () {\n      if (latestAnimationFrame.current) {\n        cancelAnimationFrame(latestAnimationFrame.current);\n      }\n    };\n  }, [dimensions]);\n\n  var handleEnter = function handleEnter() {\n    transitionState.current = 'entered';\n    update();\n  };\n\n  var update = function update() {\n    var prevHeight = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var prevWidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    if (!isShown || !targetRef.current || !positionerRef.current) return;\n    var targetRect = targetRef.current.getBoundingClientRect();\n    var hasEntered = positionerRef.current.getAttribute('data-state') === 'entered';\n    var viewportHeight = document.documentElement.clientHeight;\n    var viewportWidth = document.documentElement.clientWidth;\n    var height;\n    var width;\n\n    if (hasEntered) {\n      // Only when the animation is done should we opt-in to `getBoundingClientRect`\n      var positionerRect = positionerRef.current.getBoundingClientRect(); // https://github.com/segmentio/evergreen/issues/255\n      // We need to ceil the width and height to prevent jitter when\n      // the window is zoomed (when `window.devicePixelRatio` is not an integer)\n\n      height = Math.round(positionerRect.height);\n      width = Math.round(positionerRect.width);\n    } else {\n      // When the animation is in flight use `offsetWidth/Height` which\n      // does not calculate the `transform` property as part of its result.\n      // There is still change on jitter during the animation (although unoticable)\n      // When the browser is zoomed in — we fix this with `Math.max`.\n      height = Math.max(positionerRef.current.offsetHeight, prevHeight);\n      width = Math.max(positionerRef.current.offsetWidth, prevWidth);\n    }\n\n    var _getPosition = getPosition({\n      position: position,\n      targetRect: targetRect,\n      targetOffset: targetOffset,\n      dimensions: {\n        height: height,\n        width: width\n      },\n      viewport: {\n        width: viewportWidth,\n        height: viewportHeight\n      },\n      viewportOffset: bodyOffset\n    }),\n        rect = _getPosition.rect,\n        transformOrigin = _getPosition.transformOrigin;\n\n    setDimensions({\n      left: rect.left,\n      top: rect.top,\n      height: height,\n      width: width,\n      transformOrigin: transformOrigin\n    });\n  };\n\n  var handleExited = function handleExited() {\n    transitionState.current = 'exited';\n    setDimensions(initialDimensions);\n    onCloseComplete();\n  };\n\n  return React.createElement(Stack, {\n    value: StackingOrder.POSITIONER\n  }, function (zIndex) {\n    return React.createElement(React.Fragment, null, target({\n      getRef: setTargetRef,\n      isShown: isShown\n    }), React.createElement(Transition, {\n      appear: true,\n      \"in\": isShown,\n      timeout: animationDuration,\n      onEnter: handleEnter,\n      onEntered: onOpenComplete,\n      onExited: handleExited,\n      unmountOnExit: true\n    }, function (state) {\n      return React.createElement(Portal, null, children({\n        top: dimensions.top,\n        left: dimensions.left,\n        state: state,\n        zIndex: zIndex,\n        css: getCSS({\n          initialScale: initialScale,\n          animationDuration: animationDuration\n        }),\n        style: {\n          transformOrigin: dimensions.transformOrigin,\n          left: dimensions.left,\n          top: dimensions.top,\n          zIndex: zIndex\n        },\n        getRef: getRef,\n        animationDuration: animationDuration\n      }));\n    }));\n  });\n});\nPositioner.propTypes = {\n  /**\n   * The position the element that is being positioned is on.\n   * Smart positioning might override this.\n   */\n  position: PropTypes.oneOf([Position.TOP, Position.TOP_LEFT, Position.TOP_RIGHT, Position.BOTTOM, Position.BOTTOM_LEFT, Position.BOTTOM_RIGHT, Position.LEFT, Position.RIGHT]),\n\n  /**\n   * When true, show the element being positioned.\n   */\n  isShown: PropTypes.bool,\n\n  /**\n   * Function that returns the element being positioned.\n   */\n  children: PropTypes.func.isRequired,\n\n  /**\n   * The minimum distance from the body to the element being positioned.\n   */\n  bodyOffset: PropTypes.number,\n\n  /**\n   * The minimum distance from the target to the element being positioned.\n   */\n  targetOffset: PropTypes.number,\n\n  /**\n   * Function that should return a node for the target.\n   * ({ getRef: () -> Ref, isShown: Bool }) -> React Node\n   */\n  target: PropTypes.func.isRequired,\n\n  /**\n   * Initial scale of the element being positioned.\n   */\n  initialScale: PropTypes.number,\n\n  /**\n   * Duration of the animation.\n   */\n  animationDuration: PropTypes.number,\n\n  /**\n   * Function that will be called when the exit transition is complete.\n   */\n  onCloseComplete: PropTypes.func,\n\n  /**\n   * Function that will be called when the enter transition is complete.\n   */\n  onOpenComplete: PropTypes.func\n};\nexport default Positioner;","map":{"version":3,"sources":["../../../src/positioner/src/Positioner.js"],"names":["animationEasing","spring","getCSS","initialScale","animationDuration","position","opacity","transitionTimingFunction","transitionDuration","transitionProperty","transform","visibility","noop","initialDimensions","left","top","height","width","transformOrigin","Positioner","memo","target","isShown","children","Position","bodyOffset","targetOffset","onOpenComplete","onCloseComplete","props","dimensions","setDimensions","useState","previousDimensions","usePrevious","latestAnimationFrame","useRef","transitionState","positionerRef","targetRef","setTargetRef","useMergedRef","getRef","useEffect","requestAnimationFrame","update","cancelAnimationFrame","handleEnter","prevHeight","prevWidth","targetRect","hasEntered","viewportHeight","document","viewportWidth","positionerRect","Math","rect","getPosition","viewport","viewportOffset","handleExited","StackingOrder","POSITIONER","state","zIndex","css","style","PropTypes","func"],"mappings":"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","sourcesContent":["import React, { memo, useState, useEffect, useRef } from 'react'\nimport PropTypes from 'prop-types'\nimport { Transition } from 'react-transition-group'\nimport { Portal } from '../../portal'\nimport { Stack } from '../../stack'\nimport { StackingOrder, Position } from '../../constants'\nimport { useMergedRef, usePrevious } from '../../hooks'\nimport getPosition from './getPosition'\n\nconst animationEasing = {\n  spring: `cubic-bezier(0.175, 0.885, 0.320, 1.175)`\n}\n\nconst getCSS = ({ initialScale, animationDuration }) => ({\n  position: 'fixed',\n  opacity: 0,\n  transitionTimingFunction: animationEasing.spring,\n  transitionDuration: `${animationDuration}ms`,\n  transitionProperty: 'opacity, transform',\n  transform: `scale(${initialScale}) translateY(-1px)`,\n  '&[data-state=\"entering\"], &[data-state=\"entered\"]': {\n    opacity: 1,\n    visibility: 'visible',\n    transform: `scale(1)`\n  },\n  '&[data-state=\"exiting\"]': {\n    opacity: 0,\n    transform: 'scale(1)'\n  }\n})\n\nconst noop = () => {}\nconst initialDimensions = {\n  left: 0,\n  top: 0,\n  height: 0,\n  width: 0,\n  transformOrigin: null\n}\n\nconst Positioner = memo(function Positioner(props) {\n  const {\n    target,\n    isShown,\n    children,\n    initialScale = 0.9,\n    animationDuration = 300,\n    position = Position.BOTTOM,\n    bodyOffset = 6,\n    targetOffset = 6,\n    onOpenComplete = noop,\n    onCloseComplete = noop\n  } = props\n\n  const [dimensions, setDimensions] = useState(initialDimensions)\n  const previousDimensions = usePrevious(dimensions, initialDimensions)\n  const latestAnimationFrame = useRef()\n  const transitionState = useRef()\n  const positionerRef = useRef()\n  const targetRef = useRef()\n  const setTargetRef = useMergedRef(targetRef)\n  const getRef = useMergedRef(positionerRef)\n\n  // Call `update` whenever the component has \"entered\" and dimensions change\n  useEffect(() => {\n    if (transitionState.current === 'entered') {\n      latestAnimationFrame.current = requestAnimationFrame(() => {\n        update(previousDimensions.height, previousDimensions.width)\n      })\n    }\n\n    return () => {\n      if (latestAnimationFrame.current) {\n        cancelAnimationFrame(latestAnimationFrame.current)\n      }\n    }\n  }, [dimensions])\n\n  const handleEnter = () => {\n    transitionState.current = 'entered'\n    update()\n  }\n\n  const update = (prevHeight = 0, prevWidth = 0) => {\n    if (!isShown || !targetRef.current || !positionerRef.current) return\n\n    const targetRect = targetRef.current.getBoundingClientRect()\n\n    const hasEntered =\n      positionerRef.current.getAttribute('data-state') === 'entered'\n\n    const viewportHeight = document.documentElement.clientHeight\n    const viewportWidth = document.documentElement.clientWidth\n\n    let height\n    let width\n    if (hasEntered) {\n      // Only when the animation is done should we opt-in to `getBoundingClientRect`\n      const positionerRect = positionerRef.current.getBoundingClientRect()\n\n      // https://github.com/segmentio/evergreen/issues/255\n      // We need to ceil the width and height to prevent jitter when\n      // the window is zoomed (when `window.devicePixelRatio` is not an integer)\n      height = Math.round(positionerRect.height)\n      width = Math.round(positionerRect.width)\n    } else {\n      // When the animation is in flight use `offsetWidth/Height` which\n      // does not calculate the `transform` property as part of its result.\n      // There is still change on jitter during the animation (although unoticable)\n      // When the browser is zoomed in — we fix this with `Math.max`.\n      height = Math.max(positionerRef.current.offsetHeight, prevHeight)\n      width = Math.max(positionerRef.current.offsetWidth, prevWidth)\n    }\n\n    const { rect, transformOrigin } = getPosition({\n      position,\n      targetRect,\n      targetOffset,\n      dimensions: {\n        height,\n        width\n      },\n      viewport: {\n        width: viewportWidth,\n        height: viewportHeight\n      },\n      viewportOffset: bodyOffset\n    })\n\n    setDimensions({\n      left: rect.left,\n      top: rect.top,\n      height,\n      width,\n      transformOrigin\n    })\n  }\n\n  const handleExited = () => {\n    transitionState.current = 'exited'\n    setDimensions(initialDimensions)\n    onCloseComplete()\n  }\n\n  return (\n    <Stack value={StackingOrder.POSITIONER}>\n      {zIndex => {\n        return (\n          <React.Fragment>\n            {target({ getRef: setTargetRef, isShown })}\n\n            <Transition\n              appear\n              in={isShown}\n              timeout={animationDuration}\n              onEnter={handleEnter}\n              onEntered={onOpenComplete}\n              onExited={handleExited}\n              unmountOnExit\n            >\n              {state => (\n                <Portal>\n                  {children({\n                    top: dimensions.top,\n                    left: dimensions.left,\n                    state,\n                    zIndex,\n                    css: getCSS({\n                      initialScale,\n                      animationDuration\n                    }),\n                    style: {\n                      transformOrigin: dimensions.transformOrigin,\n                      left: dimensions.left,\n                      top: dimensions.top,\n                      zIndex\n                    },\n                    getRef,\n                    animationDuration\n                  })}\n                </Portal>\n              )}\n            </Transition>\n          </React.Fragment>\n        )\n      }}\n    </Stack>\n  )\n})\n\nPositioner.propTypes = {\n  /**\n   * The position the element that is being positioned is on.\n   * Smart positioning might override this.\n   */\n  position: PropTypes.oneOf([\n    Position.TOP,\n    Position.TOP_LEFT,\n    Position.TOP_RIGHT,\n    Position.BOTTOM,\n    Position.BOTTOM_LEFT,\n    Position.BOTTOM_RIGHT,\n    Position.LEFT,\n    Position.RIGHT\n  ]),\n\n  /**\n   * When true, show the element being positioned.\n   */\n  isShown: PropTypes.bool,\n\n  /**\n   * Function that returns the element being positioned.\n   */\n  children: PropTypes.func.isRequired,\n\n  /**\n   * The minimum distance from the body to the element being positioned.\n   */\n  bodyOffset: PropTypes.number,\n\n  /**\n   * The minimum distance from the target to the element being positioned.\n   */\n  targetOffset: PropTypes.number,\n\n  /**\n   * Function that should return a node for the target.\n   * ({ getRef: () -> Ref, isShown: Bool }) -> React Node\n   */\n  target: PropTypes.func.isRequired,\n\n  /**\n   * Initial scale of the element being positioned.\n   */\n  initialScale: PropTypes.number,\n\n  /**\n   * Duration of the animation.\n   */\n  animationDuration: PropTypes.number,\n\n  /**\n   * Function that will be called when the exit transition is complete.\n   */\n  onCloseComplete: PropTypes.func,\n\n  /**\n   * Function that will be called when the enter transition is complete.\n   */\n  onOpenComplete: PropTypes.func\n}\n\nexport default Positioner\n"]},"metadata":{},"sourceType":"module"}