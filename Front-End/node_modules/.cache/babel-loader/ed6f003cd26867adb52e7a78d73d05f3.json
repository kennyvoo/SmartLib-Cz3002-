{"ast":null,"code":"(function () {\n  var basenameMatch, computeMatch, isMatch, isWordStart, match, mergeMatches, scoreAcronyms, scoreCharacter, scoreConsecutives, _ref;\n\n  _ref = require('./scorer'), isMatch = _ref.isMatch, isWordStart = _ref.isWordStart, scoreConsecutives = _ref.scoreConsecutives, scoreCharacter = _ref.scoreCharacter, scoreAcronyms = _ref.scoreAcronyms;\n\n  exports.match = match = function (string, query, options) {\n    var allowErrors, baseMatches, matches, pathSeparator, preparedQuery, string_lw;\n    allowErrors = options.allowErrors, preparedQuery = options.preparedQuery, pathSeparator = options.pathSeparator;\n\n    if (!(allowErrors || isMatch(string, preparedQuery.core_lw, preparedQuery.core_up))) {\n      return [];\n    }\n\n    string_lw = string.toLowerCase();\n    matches = computeMatch(string, string_lw, preparedQuery);\n\n    if (matches.length === 0) {\n      return matches;\n    }\n\n    if (string.indexOf(pathSeparator) > -1) {\n      baseMatches = basenameMatch(string, string_lw, preparedQuery, pathSeparator);\n      matches = mergeMatches(matches, baseMatches);\n    }\n\n    return matches;\n  };\n\n  exports.wrap = function (string, query, options) {\n    var matchIndex, matchPos, matchPositions, output, strPos, tagClass, tagClose, tagOpen, _ref1;\n\n    if (options.wrap != null) {\n      _ref1 = options.wrap, tagClass = _ref1.tagClass, tagOpen = _ref1.tagOpen, tagClose = _ref1.tagClose;\n    }\n\n    if (tagClass == null) {\n      tagClass = 'highlight';\n    }\n\n    if (tagOpen == null) {\n      tagOpen = '<strong class=\"' + tagClass + '\">';\n    }\n\n    if (tagClose == null) {\n      tagClose = '</strong>';\n    }\n\n    if (string === query) {\n      return tagOpen + string + tagClose;\n    }\n\n    matchPositions = match(string, query, options);\n\n    if (matchPositions.length === 0) {\n      return string;\n    }\n\n    output = '';\n    matchIndex = -1;\n    strPos = 0;\n\n    while (++matchIndex < matchPositions.length) {\n      matchPos = matchPositions[matchIndex];\n\n      if (matchPos > strPos) {\n        output += string.substring(strPos, matchPos);\n        strPos = matchPos;\n      }\n\n      while (++matchIndex < matchPositions.length) {\n        if (matchPositions[matchIndex] === matchPos + 1) {\n          matchPos++;\n        } else {\n          matchIndex--;\n          break;\n        }\n      }\n\n      matchPos++;\n\n      if (matchPos > strPos) {\n        output += tagOpen;\n        output += string.substring(strPos, matchPos);\n        output += tagClose;\n        strPos = matchPos;\n      }\n    }\n\n    if (strPos <= string.length - 1) {\n      output += string.substring(strPos);\n    }\n\n    return output;\n  };\n\n  basenameMatch = function (subject, subject_lw, preparedQuery, pathSeparator) {\n    var basePos, depth, end;\n    end = subject.length - 1;\n\n    while (subject[end] === pathSeparator) {\n      end--;\n    }\n\n    basePos = subject.lastIndexOf(pathSeparator, end);\n\n    if (basePos === -1) {\n      return [];\n    }\n\n    depth = preparedQuery.depth;\n\n    while (depth-- > 0) {\n      basePos = subject.lastIndexOf(pathSeparator, basePos - 1);\n\n      if (basePos === -1) {\n        return [];\n      }\n    }\n\n    basePos++;\n    end++;\n    return computeMatch(subject.slice(basePos, end), subject_lw.slice(basePos, end), preparedQuery, basePos);\n  };\n\n  mergeMatches = function (a, b) {\n    var ai, bj, i, j, m, n, out;\n    m = a.length;\n    n = b.length;\n\n    if (n === 0) {\n      return a.slice();\n    }\n\n    if (m === 0) {\n      return b.slice();\n    }\n\n    i = -1;\n    j = 0;\n    bj = b[j];\n    out = [];\n\n    while (++i < m) {\n      ai = a[i];\n\n      while (bj <= ai && ++j < n) {\n        if (bj < ai) {\n          out.push(bj);\n        }\n\n        bj = b[j];\n      }\n\n      out.push(ai);\n    }\n\n    while (j < n) {\n      out.push(b[j++]);\n    }\n\n    return out;\n  };\n\n  computeMatch = function (subject, subject_lw, preparedQuery, offset) {\n    var DIAGONAL, LEFT, STOP, UP, acro_score, align, backtrack, csc_diag, csc_row, csc_score, i, j, m, matches, move, n, pos, query, query_lw, score, score_diag, score_row, score_up, si_lw, start, trace;\n\n    if (offset == null) {\n      offset = 0;\n    }\n\n    query = preparedQuery.query;\n    query_lw = preparedQuery.query_lw;\n    m = subject.length;\n    n = query.length;\n    acro_score = scoreAcronyms(subject, subject_lw, query, query_lw).score;\n    score_row = new Array(n);\n    csc_row = new Array(n);\n    STOP = 0;\n    UP = 1;\n    LEFT = 2;\n    DIAGONAL = 3;\n    trace = new Array(m * n);\n    pos = -1;\n    j = -1;\n\n    while (++j < n) {\n      score_row[j] = 0;\n      csc_row[j] = 0;\n    }\n\n    i = -1;\n\n    while (++i < m) {\n      score = 0;\n      score_up = 0;\n      csc_diag = 0;\n      si_lw = subject_lw[i];\n      j = -1;\n\n      while (++j < n) {\n        csc_score = 0;\n        align = 0;\n        score_diag = score_up;\n\n        if (query_lw[j] === si_lw) {\n          start = isWordStart(i, subject, subject_lw);\n          csc_score = csc_diag > 0 ? csc_diag : scoreConsecutives(subject, subject_lw, query, query_lw, i, j, start);\n          align = score_diag + scoreCharacter(i, j, start, acro_score, csc_score);\n        }\n\n        score_up = score_row[j];\n        csc_diag = csc_row[j];\n\n        if (score > score_up) {\n          move = LEFT;\n        } else {\n          score = score_up;\n          move = UP;\n        }\n\n        if (align > score) {\n          score = align;\n          move = DIAGONAL;\n        } else {\n          csc_score = 0;\n        }\n\n        score_row[j] = score;\n        csc_row[j] = csc_score;\n        trace[++pos] = score > 0 ? move : STOP;\n      }\n    }\n\n    i = m - 1;\n    j = n - 1;\n    pos = i * n + j;\n    backtrack = true;\n    matches = [];\n\n    while (backtrack && i >= 0 && j >= 0) {\n      switch (trace[pos]) {\n        case UP:\n          i--;\n          pos -= n;\n          break;\n\n        case LEFT:\n          j--;\n          pos--;\n          break;\n\n        case DIAGONAL:\n          matches.push(i + offset);\n          j--;\n          i--;\n          pos -= n + 1;\n          break;\n\n        default:\n          backtrack = false;\n      }\n    }\n\n    matches.reverse();\n    return matches;\n  };\n}).call(this);","map":{"version":3,"sources":["D:/Projects/CZ3002-Lab-SmartLib/CZ3002_Xeon/Front-End/node_modules/fuzzaldrin-plus/lib/matcher.js"],"names":["basenameMatch","computeMatch","isMatch","isWordStart","match","mergeMatches","scoreAcronyms","scoreCharacter","scoreConsecutives","_ref","require","exports","string","query","options","allowErrors","baseMatches","matches","pathSeparator","preparedQuery","string_lw","core_lw","core_up","toLowerCase","length","indexOf","wrap","matchIndex","matchPos","matchPositions","output","strPos","tagClass","tagClose","tagOpen","_ref1","substring","subject","subject_lw","basePos","depth","end","lastIndexOf","slice","a","b","ai","bj","i","j","m","n","out","push","offset","DIAGONAL","LEFT","STOP","UP","acro_score","align","backtrack","csc_diag","csc_row","csc_score","move","pos","query_lw","score","score_diag","score_row","score_up","si_lw","start","trace","Array","reverse","call"],"mappings":"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","sourcesContent":["(function() {\n  var basenameMatch, computeMatch, isMatch, isWordStart, match, mergeMatches, scoreAcronyms, scoreCharacter, scoreConsecutives, _ref;\n\n  _ref = require('./scorer'), isMatch = _ref.isMatch, isWordStart = _ref.isWordStart, scoreConsecutives = _ref.scoreConsecutives, scoreCharacter = _ref.scoreCharacter, scoreAcronyms = _ref.scoreAcronyms;\n\n  exports.match = match = function(string, query, options) {\n    var allowErrors, baseMatches, matches, pathSeparator, preparedQuery, string_lw;\n    allowErrors = options.allowErrors, preparedQuery = options.preparedQuery, pathSeparator = options.pathSeparator;\n    if (!(allowErrors || isMatch(string, preparedQuery.core_lw, preparedQuery.core_up))) {\n      return [];\n    }\n    string_lw = string.toLowerCase();\n    matches = computeMatch(string, string_lw, preparedQuery);\n    if (matches.length === 0) {\n      return matches;\n    }\n    if (string.indexOf(pathSeparator) > -1) {\n      baseMatches = basenameMatch(string, string_lw, preparedQuery, pathSeparator);\n      matches = mergeMatches(matches, baseMatches);\n    }\n    return matches;\n  };\n\n  exports.wrap = function(string, query, options) {\n    var matchIndex, matchPos, matchPositions, output, strPos, tagClass, tagClose, tagOpen, _ref1;\n    if ((options.wrap != null)) {\n      _ref1 = options.wrap, tagClass = _ref1.tagClass, tagOpen = _ref1.tagOpen, tagClose = _ref1.tagClose;\n    }\n    if (tagClass == null) {\n      tagClass = 'highlight';\n    }\n    if (tagOpen == null) {\n      tagOpen = '<strong class=\"' + tagClass + '\">';\n    }\n    if (tagClose == null) {\n      tagClose = '</strong>';\n    }\n    if (string === query) {\n      return tagOpen + string + tagClose;\n    }\n    matchPositions = match(string, query, options);\n    if (matchPositions.length === 0) {\n      return string;\n    }\n    output = '';\n    matchIndex = -1;\n    strPos = 0;\n    while (++matchIndex < matchPositions.length) {\n      matchPos = matchPositions[matchIndex];\n      if (matchPos > strPos) {\n        output += string.substring(strPos, matchPos);\n        strPos = matchPos;\n      }\n      while (++matchIndex < matchPositions.length) {\n        if (matchPositions[matchIndex] === matchPos + 1) {\n          matchPos++;\n        } else {\n          matchIndex--;\n          break;\n        }\n      }\n      matchPos++;\n      if (matchPos > strPos) {\n        output += tagOpen;\n        output += string.substring(strPos, matchPos);\n        output += tagClose;\n        strPos = matchPos;\n      }\n    }\n    if (strPos <= string.length - 1) {\n      output += string.substring(strPos);\n    }\n    return output;\n  };\n\n  basenameMatch = function(subject, subject_lw, preparedQuery, pathSeparator) {\n    var basePos, depth, end;\n    end = subject.length - 1;\n    while (subject[end] === pathSeparator) {\n      end--;\n    }\n    basePos = subject.lastIndexOf(pathSeparator, end);\n    if (basePos === -1) {\n      return [];\n    }\n    depth = preparedQuery.depth;\n    while (depth-- > 0) {\n      basePos = subject.lastIndexOf(pathSeparator, basePos - 1);\n      if (basePos === -1) {\n        return [];\n      }\n    }\n    basePos++;\n    end++;\n    return computeMatch(subject.slice(basePos, end), subject_lw.slice(basePos, end), preparedQuery, basePos);\n  };\n\n  mergeMatches = function(a, b) {\n    var ai, bj, i, j, m, n, out;\n    m = a.length;\n    n = b.length;\n    if (n === 0) {\n      return a.slice();\n    }\n    if (m === 0) {\n      return b.slice();\n    }\n    i = -1;\n    j = 0;\n    bj = b[j];\n    out = [];\n    while (++i < m) {\n      ai = a[i];\n      while (bj <= ai && ++j < n) {\n        if (bj < ai) {\n          out.push(bj);\n        }\n        bj = b[j];\n      }\n      out.push(ai);\n    }\n    while (j < n) {\n      out.push(b[j++]);\n    }\n    return out;\n  };\n\n  computeMatch = function(subject, subject_lw, preparedQuery, offset) {\n    var DIAGONAL, LEFT, STOP, UP, acro_score, align, backtrack, csc_diag, csc_row, csc_score, i, j, m, matches, move, n, pos, query, query_lw, score, score_diag, score_row, score_up, si_lw, start, trace;\n    if (offset == null) {\n      offset = 0;\n    }\n    query = preparedQuery.query;\n    query_lw = preparedQuery.query_lw;\n    m = subject.length;\n    n = query.length;\n    acro_score = scoreAcronyms(subject, subject_lw, query, query_lw).score;\n    score_row = new Array(n);\n    csc_row = new Array(n);\n    STOP = 0;\n    UP = 1;\n    LEFT = 2;\n    DIAGONAL = 3;\n    trace = new Array(m * n);\n    pos = -1;\n    j = -1;\n    while (++j < n) {\n      score_row[j] = 0;\n      csc_row[j] = 0;\n    }\n    i = -1;\n    while (++i < m) {\n      score = 0;\n      score_up = 0;\n      csc_diag = 0;\n      si_lw = subject_lw[i];\n      j = -1;\n      while (++j < n) {\n        csc_score = 0;\n        align = 0;\n        score_diag = score_up;\n        if (query_lw[j] === si_lw) {\n          start = isWordStart(i, subject, subject_lw);\n          csc_score = csc_diag > 0 ? csc_diag : scoreConsecutives(subject, subject_lw, query, query_lw, i, j, start);\n          align = score_diag + scoreCharacter(i, j, start, acro_score, csc_score);\n        }\n        score_up = score_row[j];\n        csc_diag = csc_row[j];\n        if (score > score_up) {\n          move = LEFT;\n        } else {\n          score = score_up;\n          move = UP;\n        }\n        if (align > score) {\n          score = align;\n          move = DIAGONAL;\n        } else {\n          csc_score = 0;\n        }\n        score_row[j] = score;\n        csc_row[j] = csc_score;\n        trace[++pos] = score > 0 ? move : STOP;\n      }\n    }\n    i = m - 1;\n    j = n - 1;\n    pos = i * n + j;\n    backtrack = true;\n    matches = [];\n    while (backtrack && i >= 0 && j >= 0) {\n      switch (trace[pos]) {\n        case UP:\n          i--;\n          pos -= n;\n          break;\n        case LEFT:\n          j--;\n          pos--;\n          break;\n        case DIAGONAL:\n          matches.push(i + offset);\n          j--;\n          i--;\n          pos -= n + 1;\n          break;\n        default:\n          backtrack = false;\n      }\n    }\n    matches.reverse();\n    return matches;\n  };\n\n}).call(this);\n"]},"metadata":{},"sourceType":"script"}